import React, { useEffect, useState, useCallback } from 'react';
import {
  StyleSheet,
  Platform,
  Linking,
  View,
  TouchableOpacity,
  KeyboardAvoidingView,
  Dimensions,
  Alert,
} from 'react-native';
import {
  PRU_SSO_BASE,
  LITMOS,
  BUILD_VERSION,
  DEFAULT_DOMAIN,
  ASKPRU,
  APIM_BASE_URL,
  APIM_CORE,
  ENCRYPTION_KEY,
  ENCRYPTION_PREFIX,
} from '@env';
import { WebView, WebViewProps } from 'react-native-webview';
import CookieManager from '@react-native-community/cookies';
import { useIsFocused, ParamListBase } from '@react-navigation/native';
import { NativeStackNavigationProp } from 'react-native-screens/native-stack';
import DeviceInfo from 'react-native-device-info';
import * as Keychain from 'react-native-keychain';
import moment from 'moment';

import {
  WebViewErrorEvent,
  WebViewNavigationEvent,
  WebViewProgressEvent,
  WebViewMessageEvent,
  OnShouldStartLoadWithRequest,
  ShouldStartLoadRequest,
} from 'react-native-webview/lib/WebViewTypes';
import Pdf from 'react-native-pdf';
import { useFocusEffect } from '@react-navigation/core';
import { useTranslation } from 'react-i18next';
import { constants, BaseApiFetchInstance } from 'common_services_frontend';
import RNFetchBlob from 'rn-fetch-blob';

import Share from 'react-native-share';
import RNFS from 'react-native-fs';
import {
  PruIconFont,
  PruHeader,
  PruScreen,
  PruActivityIndicator,
  Toast as PruToast,
} from '../../components';
import {palette as PruPalette} from '../../theme'
import {Colors} from '../../style'
import { api } from './api';
import LoadingBar from './LoadingBar';
import { decrypt } from '../../pruforce';

const styles = StyleSheet.create({
  ROOT: {
    backgroundColor: PruPalette.white,
  },
  HEAD: {
    borderBottomWidth: 1,
    borderBottomColor: PruPalette.greyeb,
  },
  container: {
    flex: 1,
    backgroundColor: PruPalette.white,
  },
  indicator: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    top: 0,
  },
  row: {
    flexDirection: 'row',
    marginBottom: 20,
    justifyContent: 'space-around',
  },
  header: {
    backgroundColor: PruPalette.white,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 3,
  },
  bottom: {
    backgroundColor: PruPalette.white,
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 20,
  },
  bottom_null: {
    backgroundColor: PruPalette.white,
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 5,
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
  },
});
export interface WebviewScreenProps {
  navigation: NativeStackNavigationProp<ParamListBase>;
  route: any;
  header?: Element;
  html?: string;
}

export const WebviewScreen: React.FunctionComponent<WebviewScreenProps & WebViewProps> = (
  props,
) => {
  let webview: WebView;
  const SendIntentAndroid = require('react-native-send-intent');
  const [webUrl, setWebUrl] = useState(props.route.params.url || props.route.params.uri || '#');
  const [webHtml, setWebHtml] = useState(props.html || props.route.params?.html || '');
  const originProps: WebViewProps = {};
  if (props.cacheEnabled) {
    originProps.cacheEnabled = props.cacheEnabled;
  }
  if (props.androidHardwareAccelerationDisabled) {
    originProps.androidHardwareAccelerationDisabled = props.androidHardwareAccelerationDisabled;
  }
  const withCookie =
    props.html || props.route.params?.html
      ? false
      : props.route.params?.withCookie || webUrl.includes(PRU_SSO_BASE);
  const {
    title,
    method = 'GET',
    cookieDomain = DEFAULT_DOMAIN,
    hideHeader = false,
    forceMobileScale = false,
    isForceDownloadFilePOST = false,
    hideFooter = false,
  } = props.route.params;
  const isFocused = useIsFocused();
  const [isInitialized, setIsInitialized] = useState(false);
  // JS Injected upon each page load
  const [INJECTEDJAVASCRIPT, setINJECTEDJAVASCRIPT] = useState({
    injectedJavaScript: `const meta = document.createElement('meta'); meta.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0'); meta.setAttribute('name', 'viewport'); document.getElementsByTagName('head')[0].appendChild(meta); `,
  });

  // Effect for route props change
  useEffect(() => {
    // Update the URL at each props URL update
    // Otherwise, upon 2nd acceess, webview sill load last URL
    setWebUrl(props.route.params.url || props.route.params.uri);
    setWebHtml(props.html || props.route.params?.html || '');
  }, [props.route.params]);

  const [isIncognito, setIsIncognito] = useState(false);
  // this is tailored to handle litmos url for SSO login
  const handleLitmos = async () => {
    if (!webUrl.includes(PRU_SSO_BASE) && webUrl.startsWith(LITMOS)) {
      let loginkeyUrl: string;
      setIsIncognito(Platform.OS === constants.Platform_IOS);
      const response = await BaseApiFetchInstance.get(
        `${APIM_BASE_URL}${APIM_CORE}/integration/token?issuer=pruexpert`,
      );
      if (response?.data?.statusCode === 404) {
        if (globalThis.CONFIGURATION?.Training?.showPRUExpertAccessErrorMessage) {
          Alert.alert('Please check your PRUExpert access');
        }
        return;
      }
      const loginKey = response?.data?.meta?.LoginKey;
      if (loginKey) {
        loginkeyUrl = `${loginKey}&skipFirstlogin=true`;
      }
      CookieManager.clearAll(true).then(() => {
        fetch(loginkeyUrl, { method: 'GET' })
          .then(() => {
            setIsInitialized(true);
          })
          .catch((innerErr: any) =>
            PruToast({
              message: `${innerErr}`,
            }),
          );
      });
    } else {
      setIsInitialized(true);
    }
  };

  useFocusEffect(
    useCallback(() => {
      if (forceMobileScale || webUrl.includes('.mp4')) {
        // Force Mobile View
        setINJECTEDJAVASCRIPT({
          injectedJavaScript: `const meta = document.createElement('meta'); meta.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0'); meta.setAttribute('name', 'viewport'); document.getElementsByTagName('head')[0].appendChild(meta); `,
        });
      } else {
        setINJECTEDJAVASCRIPT({});
      }
      handleLitmos();
      return () => {
        CookieManager.clearAll();
        setIsInitialized(false);
        setIsIncognito(false);
        setCurUrl('');
      };
    }, []),
  );

  const { t, i18n } = useTranslation();
  // const agentCode = useSelector<any, string>((state) => {
  //   return state.auth.agentCode;
  // });
  // State
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState('');
  const [userAgent, setUserAgent] = useState('');
  const [webpageCookie, setWebpageCookie] = useState('');

  // Loading Bar
  const disappearDuration = 3000;
  const [percent, setPercent] = useState(0);
  const [barColor, setBarColor] = useState(Colors.primaryRed);
  const [curUrl, setCurUrl] = useState(webUrl);
  const [canShare, setCanShare] = useState(false);

  // Popup
  const [popUpWebViewURL, setPopUpWebViewURL] = useState(null);
  const [isShowAndroidPdfView, setIsShowAndroidPdfView] = useState(false);
  const [popUpWebViewMethod, setPopUpWebViewMethod] = useState('GET');
  const [popUpWebViewPOSTData, setPopUpWebViewPOSTData] = useState('');
  const [popUpWebViewRequestHeader, setPopUpWebViewRequestHeader] = useState('');

  // File Sharing
  const [isShowDownloadFileMode, setIsShowDownloadFileMode] = useState(false);
  const [downloadedFileInfo, setDownloadedFileInfo] = useState({});
  const [isLoadingFile, setIsLoadingFile] = useState(false);

  function LoadingIndicatorView() {
    return <PruActivityIndicator style={styles.indicator} />;
  }

  DeviceInfo.getUserAgent().then((res: string) => {
    setUserAgent(res);
  });
  const cookieManage = (cookieKey: string, cookie: string) => {
    if (withCookie) {
      CookieManager.set(webUrl, {
        name: cookieKey,
        value: cookie,
        domain: cookieDomain,
        path: '/',
        version: '1',
        expires: moment().add(7, 'days').format('YYYY-MM-DDTHH:mm:ss.sssZ'),
      });
      CookieManager.set(webUrl, {
        name: 'PRUforce',
        value: BUILD_VERSION,
        domain: cookieDomain,
        path: '/',
        version: '1',
        expires: moment().add(7, 'days').format('YYYY-MM-DDTHH:mm:ss.sssZ'),
      });
      setData(cookie);
    }
  };
  useEffect(() => {
    if (withCookie && isFocused) {
      Keychain.getGenericPassword().then((credentials) => {
        let username;
        let password;
        // @ts-ignore
        username = credentials.username;
        // @ts-ignore
        password = credentials.password;
        if (username && password) {
          password = decrypt(password);
          api
            .getSAAMToken(password)
            .then((result) => {
              if (result.kind === 'ok') {
                cookieManage(result.saamResponse.cookieKey, result.saamResponse.cookieValue);
              }
              setLoading(false);
            })
            .catch((error) => console.error(error));
        }
      });
    }
    return () => {
      setData('');
      CookieManager.clearAll();
    };
  }, [isFocused]);

  /**
   * React Native Webview public methods
   * https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#onload
   */

  // Invoked when the WebView starts loading
  const onLoadStart = (syntheticEvent: WebViewNavigationEvent) => {
    const { nativeEvent } = syntheticEvent;
    // console.log("onLoadStart",syntheticEvent);

    // Config Loading Bar
    setBarColor(Colors.primaryRed);
    setPercent(5);
  };

  // Invoked when the WebView is loading.
  const onLoadProgress = (syntheticEvent: WebViewProgressEvent) => {
    const { nativeEvent } = syntheticEvent;
    // console.log("onLoadProgress",syntheticEvent);

    setPercent(syntheticEvent.nativeEvent.progress);
  };

  // Invoked when the WebView load succeeds or fails
  const onLoadEnd = (syntheticEvent: WebViewNavigationEvent | WebViewErrorEvent) => {
    // console.log("onLoadEnd",syntheticEvent);

    // Get the webview cookie for later use (e.g. File Sharing)
    // onMessage() call will receive response at next
    webview.injectJavaScript(
      `var webCookie = encodeURIComponent(document.cookie); window.ReactNativeWebView.postMessage('{ "action" : "getwebcookie", "payload" : { "cookies" : "'+webCookie+'"} }');`,
    );
  };

  // Invoked when the WebView load fails
  const onError = (syntheticEvent: WebViewErrorEvent) => {
    const { nativeEvent } = syntheticEvent;
    // console.log("onError",syntheticEvent);

    // Config Loading Bar
    setBarColor(Colors.primaryRed);
    setPercent(100);

    console.warn('WebView onError: ', nativeEvent);
  };

  // Invoked when the webview calls window.ReactNativeWebView.postMessage
  const onMessage = (event: WebViewMessageEvent) => {
    // event.nativeEvent.data must be string

    // Handle Incoming data
    const webviewMessageData = JSON.parse(event.nativeEvent.data);
    const { action, payload } = webviewMessageData;
    // console.log('Webview onMessage - raw data', event.nativeEvent.data);
    // console.log('Webview onMessage - webviewMessageData', webviewMessageData);
    console.log('Webview onMessage - action', action);
    console.log('Webview onMessage - payload', payload);

    switch (action.toLowerCase()) {
      case 'loadurlwithtarget':
        /**
         * Load URL with target
         *
         * Payload:
         *  url     - URL to be load
         *  target  - _self or _blank
         *  method  - GET or POST
         *  data    - URL encoded string (for Form POST Data)
         *
         * Sample Input:
         * window.ReactNativeWebView.postMessage('{ "action" : "loadurlwithtarget", "payload" : { "target" : "_blank", "url" : "https%3A%2F%2Fapuat.prudential.com.hk%2Fsaes%2Fproposalpolicy%2FpolicyDetails%3Fpolicy_no%3D000020035100%26agent_cd%3D00010008%26branch_cd%3D%26locale%3Dzh%26change_tab_to%3DeEnquiry%26token%3De8966fd0-f45d-4e94-99e8-b62a8dfbade8%26source%3Daskpru" } }');
         */

        const url = decodeURIComponent(payload?.url);
        // Target
        const inputTarget = payload?.target;
        const target =
          inputTarget &&
          (inputTarget.toLowerCase() == '_self' || inputTarget.toLowerCase() == '_blank')
            ? inputTarget
            : '_self';
        // Method
        const inputMethod = payload?.method;
        const currentMethod =
          inputMethod && (inputMethod.toUpperCase() == 'POST' || inputMethod.toUpperCase() == 'GET')
            ? inputMethod
            : 'GET';
        // POST Data - Encoded URL format (e.g. eenquiry_msg%3DFwefw%26source%3Daskpru)
        // Replace with line break for text area /r/n
        const inputPostData = payload?.data;
        const postData =
          inputPostData && inputPostData.length > 0
            ? decodeURIComponent(inputPostData).replace(/\\n/g, '\n').replace(/\\r/g, '\r')
            : '';

        // console.log('Webview onMessage - payload url', url);
        // console.log('Webview onMessage - target', target);
        // console.log('Webview onMessage - currentMethod', currentMethod);
        // console.log('Webview onMessage - decodeURIComponent postData', postData );

        if (!url) return;
        if (target === '_blank') {
          // Load with Popup Webview
          loadSecondTab(url, false, currentMethod, encodeURI(postData));
        } else {
          // Load with Main Webview
          setWebUrl(url || '#');
        }
        break;
      case 'getwebcookie':
        /**
         * Get and store current webview cookie for File Sharing
         *
         * Payload:
         *  cookies - Encoded 'document.cookies' response
         *
         * Sample Input:
         * window.ReactNativeWebView.postMessage('{ "action" : "getwebcookie", "payload" : { "cookies" : "'+webCookie+'"} }');
         */

        if (payload?.cookies) {
          const returnCookie = decodeURIComponent(payload?.cookies);
          // console.log('onMessage - getwebcookie', returnCookie);
          setWebpageCookie(returnCookie);
        } else {
          console.log('onMessage() - getwebcookie - No Cookie Payload');
          setWebpageCookie('');
        }

        break;
      default:
    }
  };

  // Allows custom handling of any web view requests
  // Return true from the function to continue loading the request and false to stop loading
  const onShouldStartLoadWithRequest: OnShouldStartLoadWithRequest = (
    request: ShouldStartLoadRequest,
  ) => {
    setCanShare(false);
    if (webview === null) return false;
    if (webHtml) return true;
    const { url }: { url?: string } = request;
    if (!url || !webview) {
      return false;
    }

    // console.log('onShouldStartLoadWithRequest - url', url);
    // Code JS Rule: Early Return
    if (url.startsWith('http') || url.startsWith('about:')) {
      if (isLoadInDownloadFileMode(url)) {
        setCurUrl(url);

        setIsLoadingFile(true);

        // Webmail - Special handling (Attachment URL only valid once)
        // Download and show in webview
        setIsShowDownloadFileMode(true);
        downloadFileToLocalDir(url);
        return false;
      }

      return true;
    }

    if (url?.includes('umsp-native')) {
      /**
       *  20201202 - Depecrated URL Scheme
       *  Tailored for "AskPru", use "onMessage" way instead
       */

      webview?.stopLoading();
      loadSecondTab(url, true, 'GET', '');

      return false;
    }

    if (!url?.startsWith('http:') && !url?.startsWith('https:')) {
      webview.stopLoading();
      if (
        url?.startsWith('tel:') ||
        url?.startsWith('mailto:') ||
        url?.startsWith('maps:') ||
        url?.startsWith('geo:') ||
        url?.startsWith('sms:') ||
        url?.startsWith('itms-apps')
      ) {
        // List of schemas we will allow the webview to open natively
        // open system intent
        Linking.canOpenURL(url)
          .then((res) => {
            if (res) {
              Linking.openURL(url);
            }
          })
          .catch((er) => {
            console.warn(`Failed to open Link: ${er.message}`);
          });
      }
      if (url.startsWith('intent:') && Platform.OS === constants.Platform_Android) {
        SendIntentAndroid.openChromeIntent(url);
      }
      return false;
    }

    // if (url?.includes('/login?challenge_url')) {
    //   this.checkShouldReLoginAndGetData();
    //   return false;
    // }

    // console.warn("onShouldStartLoadWithRequest - url- true:",url);
    return true;
  };

  /**
   * Custom URL Logic
   */

  const decodeCustomURL = (url: string): string | null => {
    let newURL = null;

    if (url?.includes('umsp-native')) {
      if (url?.includes('%7C%7C')) {
        newURL = url?.split('%7C%7C')[1];
      }

      if (url?.includes('||')) {
        newURL = url?.split('||')[1];
      }
    }

    return newURL;
  };

  /**
   * Load Popup Webview overlay on top of tha main webview
   * @param url - URL load by Popup Webview
   * @param isRequireUMSPDecode - Decode UMSP URL Scheme for Webview<->Native actions
   * @param method - Load Method, GET or POST
   * @param postDataStr - POST data in URL string format
   */
  const loadSecondTab = (
    url: string,
    isRequireUMSPDecode: boolean = false,
    method: string = 'GET',
    postDataStr: string = '',
  ) => {
    const newURL = isRequireUMSPDecode ? decodeCustomURL(url) : url;
    const showAndroidPDFView = newURL?.toLowerCase().includes('.pdf') && Platform.OS === 'android';
    const requestHeader =
      Platform.OS === 'ios' ? { 'Content-Type': 'application/x-www-form-urlencoded' } : '';

    // Handle POST Form
    if (method.toUpperCase() === 'POST') {
      // Fix known issue that iOS do not have correct header for FORM POST
      // Ref: https://github.com/react-native-webview/react-native-webview/issues/892
      setPopUpWebViewRequestHeader(requestHeader);
      setPopUpWebViewPOSTData(postDataStr);
    }

    setPopUpWebViewMethod(method);
    setPopUpWebViewURL(newURL);
    setIsShowAndroidPdfView(showAndroidPDFView);
  };

  const onBackClick = async () => {
    if (webview === null) return;

    if (popUpWebViewURL) {
      // Clear PopupwebView data
      setPopUpWebViewMethod('GET');
      setPopUpWebViewPOSTData('');
      setPopUpWebViewRequestHeader('');

      setPopUpWebViewURL(null);
      setIsShowAndroidPdfView(false);

      if (isShowDownloadFileMode) {
        await onExitDownloadFileMode(popUpWebViewURL);
      }
    }
    // if (Platform.OS === 'android') {
    //   // AskPRU will keep redirect
    //   // So need to block back button on android otherwise will keep reloading
    //   return;
    // } else
    else {
      webview.goBack();
    }
  };

  const onExitDownloadFileMode = async (filePathURL: string) => {
    // Remove File when popup webview is closed
    setIsShowDownloadFileMode(false);
    setDownloadedFileInfo({});
    setCanShare(false);

    // Remove download file from
    await RNFS.unlink(filePathURL).then(() => {
      console.log('filePathURL - File removed', filePathURL);
    });
  };

  const isLoadInDownloadFileMode = (url: string, inputFileType: string = '') => {
    let fileType: string =
      inputFileType && inputFileType.length > 0 ? inputFileType : url.replace(/.+\./, '');
    fileType = fileType.toLocaleLowerCase();

    const webmailAttachementURL = '/owa/service.svc/s/GetFileAttachment?id=';
    const isPILWebFileViewerURL =
      url.includes('/_layouts/WordViewer.aspx?') || url.includes('/_layouts/PowerPoint.aspx?');

    return (
      Platform.OS === 'ios' &&
      isForceDownloadFilePOST && // Default false, PIL & Webmail set as true
      !isPILWebFileViewerURL &&
      (constants.FileType.PDF === fileType ||
        constants.FileType.IMG.includes(fileType) ||
        url.includes('.mp4') ||
        url.includes('.xls') ||
        url.includes('.doc') ||
        url.includes('.ppt') ||
        url.includes(webmailAttachementURL))
    );
  };

  const getCombinedCookieString = async () => {
    // Get all existing cookies in WKHTTPCookieStore(Webview) and Local Cookie Store
    // Ref: https://github.com/react-native-cookies/cookies#webkit-support-ios-only

    const useWebKit = true;
    const allCookies = await CookieManager.getAll(useWebKit).then((cookies) => {
      let cookiesstring = '';
      // console.log('LocalCookieManager - getAll() =>', JSON.stringify(cookies));

      // Construct Request Cookie String
      for (const key in cookies) {
        // console.log(`${key}: ${cookies[key]}`);
        const { name, value } = cookies[key];
        cookiesstring += `${name}=${value};`;
      }
      cookiesstring = webpageCookie + cookiesstring;
      // console.log('getCombinedCookieString', cookiesstring);

      return cookiesstring;
    });
    return allCookies;
  };

  const checkTargetPathIsClean = async (dst) => {
    // Check if the target path is clean
    // Remove if target file exists
    await RNFS.exists(dst).then(async (dirExists) => {
      console.log('dirExists', dirExists);
      if (dirExists) {
        await RNFS.unlink(dst).then(() => {
          console.log('Deleted File form Path:', dst);
        });
      } else {
        console.log('Target File Path Can write:', dst);
      }
    });
  };

  const downloadFileToLocalDir = async (downloadURL: string = '') => {
    if (!(downloadURL && downloadURL.length > 0)) {
      console.log('Incorrect downloadURL:', downloadURL);
      return;
    }
    const decodedDownloadURL = decodeURIComponent(downloadURL);

    // Get Cookie and download file to local
    if (Platform.OS === 'ios') {
      // const useWebKit = true;
      // CookieManager.getAll(useWebKit).then((cookies) => {
      // [iOS Only] Get all existing cookies in WKHTTPCookieStore(Webview) and Local Cookie Store
      // Ref: https://github.com/react-native-cookies/cookies#webkit-support-ios-only

      let cookiesstring = '';
      // console.log('LocalCookieManager - getAll() =>', JSON.stringify(cookies));

      // // Construct Request Cookie String
      // for (const key in cookies) {
      //   // console.log(`${key}: ${cookies[key]}`);
      //   const { name, value } = cookies[key];
      //   cookiesstring += `${name}=${value};`;
      // }
      // cookiesstring = webpageCookie + cookiesstring;
      cookiesstring = await getCombinedCookieString();
      // console.log('getCombinedCookieString', cookiesstring);

      const regex = /(.*\/)*([^.]+).*/gi;
      let strFileName = decodedDownloadURL.replace(regex, '$2');
      let fileType: string = decodedDownloadURL.replace(/.+\./, '');
      strFileName = strFileName.replace(`.${fileType}`, `.${fileType}`.toLocaleLowerCase());
      fileType = fileType.toLocaleLowerCase();

      const fileNameWithType = `${strFileName}.${fileType}`;

      const reqType = isForceDownloadFilePOST ? 'POST' : 'GET';

      // Construct request header
      let reqHeader = {};
      if (cookiesstring && cookiesstring.length > 0) {
        reqHeader = { ...reqHeader, Cookie: cookiesstring };
      }

      const targetFilePath = `${RNFetchBlob.fs.dirs.CacheDir}/${
        strFileName.endsWith(`.${fileType}`) ? strFileName : fileNameWithType
      }`;
      // Check if there is existing file
      await checkTargetPathIsClean(targetFilePath);

      await RNFetchBlob.config({
        fileCache: true,
        appendExt: fileType,
        path: targetFilePath,
      })
        .fetch(reqType, downloadURL, reqHeader)
        .then(
          async (resp) => {
            console.log('resp', resp);
            console.log('resp.respInfo', resp.respInfo);

            const { status } = resp.respInfo;
            console.log('status!= 200', status != 200);
            if (status != 200) {
              Alert.alert(
                t(
                  'Common:download_file_error',
                  "Sorry, the link can't be opened. Please try again by re-enter the module or refresh the page.",
                ),
              );
              setIsLoadingFile(false);

              if (isShowDownloadFileMode) {
                await onExitDownloadFileMode(targetFilePath);
              }

              return;
            }
            // Detect and decode to a correct filename
            let fileName: any = 'Unnamed' + Date.now();
            if (strFileName && strFileName.length > 0 && fileType && fileType.length > 0) {
              // Check if Filename can be obtain from URL (e.g. xxx.pdf)
              fileName = fileNameWithType;
            } else {
              // Try to get the filename from Response Header
              const responseHeaders = resp?.respInfo.headers || {};
              console.log('ResponseHeaders:', responseHeaders);

              if (responseHeaders['Content-Disposition']) {
                const regResult =
                  /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/i.exec(
                    responseHeaders['Content-Disposition'],
                  ) as string[];
                fileName = regResult[0].replace('filename="', '').replace('"', '');
                fileName = decodeURIComponent(fileName);
              }
            }

            // Rename File to target file name
            const tempFilePath = resp.path();
            const newFilePath = `${RNFetchBlob.fs.dirs.CacheDir}/${fileName}`;

            console.log('tempFilePath', tempFilePath);
            console.log('Final Target Filename:', fileName);
            console.log('Final FilePath:', newFilePath);

            if (tempFilePath !== newFilePath) {
              // Check if there is existing file
              await checkTargetPathIsClean(newFilePath);

              await RNFS.moveFile(tempFilePath, newFilePath);
            }

            let options = {
              type: fileType,
              url: `${newFilePath}`, // (Platform.OS === 'android' ? 'file://' + filePath)
            };
            setDownloadedFileInfo(options);
            setIsLoadingFile(false);

            // Final Check on download file type
            // e.g. Webmail .ics file can trigger download popup
            if (isLoadInDownloadFileMode(newFilePath, fileType)) {
              // Load file in webview and enable File sharing button
              setCanShare(true);
              loadSecondTab(newFilePath, false, 'GET', '');
            } else {
              // Trigger File sharing directly
              await Share.open(options);
            }
          },
          async (err) => {
            console.log('downloadFileToLocalDir() - Download File Err', err);
            if (isShowDownloadFileMode) {
              await onExitDownloadFileMode(popUpWebViewURL ? popUpWebViewURL : '');
            }
          },
        );
      // });
    }
  };

  const handleRightPress = async () => {
    const shareUrl = popUpWebViewURL || curUrl;

    if (!canShare) {
      console.log('Sorry cannot share');
      return;
    }

    await Share.open(downloadedFileInfo);
    // PruShareFiles(downloadedFileInfo);
  };

  const handleSpecialFileExt = (url: string) => {
    let fileType: string = url.replace(/.+\./, '');
    fileType = fileType.toLocaleLowerCase();
    let renderredContent;
    if (constants.FileType.IMG.includes(fileType) && Platform.OS === constants.Platform_Android) {
      renderredContent = {
        baseUrl: url,
        html: `<img width="100%" src="${url}" />`,
      };
    } else if (fileType === 'mp4') {
      renderredContent = {
        baseUrl: url,
        html: `<video controls preload="metadata" width="100%" height="100%"><source src="${url}#t=0.1" type="video/mp4"></video>`,
      };
    } else {
      renderredContent = {
        uri: url || '#',
        method: method === 'POST' || method === 'GET' ? method : 'GET',
      };
    }
    return renderredContent;
  };

  return (
    <PruScreen style={styles.ROOT}>
      {hideHeader
        ? null
        : props.header || (
            <PruHeader
              style={styles.HEAD}
              headerText={title}
              titleStyle={{
                fontSize: 20,
                fontWeight: 'bold',
                color: PruPalette.grey33,
                textAlign: 'left',
              }}
              leftIcon={popUpWebViewURL !== null ? 'close' : 'arrow_back'}
              onLeftPress={() => {
                if (popUpWebViewURL !== null) {
                  onBackClick();
                } else {
                  props.navigation.goBack();
                }
              }}
              rightIcon={canShare ? 'share' : undefined}
              onRightPress={() => {
                handleRightPress();
              }}
            />
          )}
      <View style={styles.header}>
        <LoadingBar height={3} color={barColor} percent={percent} />
      </View>

      <KeyboardAvoidingView style={{ flex: 1 }}>
        {isLoadingFile ? <View style={{ height: '100%' }}>{LoadingIndicatorView()}</View> : <></>}
        {popUpWebViewURL !== null && (
          <View style={{ height: '100%' }}>
            {isShowAndroidPdfView ? (
              <Pdf
                source={{ uri: popUpWebViewURL }}
                style={{
                  flex: 1,
                  width: Dimensions.get('window').width,
                  height: Dimensions.get('window').height,
                }}
              />
            ) : (
              <WebView
                injectedJavaScript={
                  INJECTEDJAVASCRIPT?.injectedJavaScript
                    ? INJECTEDJAVASCRIPT.injectedJavaScript
                    : ''
                }
                ref={(c) => (webview = c)}
                source={
                  popUpWebViewRequestHeader
                    ? {
                        uri: popUpWebViewURL,
                        headers: popUpWebViewRequestHeader,
                        method: popUpWebViewMethod,
                        body: popUpWebViewPOSTData,
                      }
                    : {
                        uri: popUpWebViewURL,
                        method: popUpWebViewMethod,
                        body: popUpWebViewPOSTData,
                      }
                }
                javaScriptEnabled
                sharedCookiesEnabled
                onLoadStart={onLoadStart}
                // onLoadEnd={onLoadEnd}
                onLoadProgress={onLoadProgress}
                onError={onError}
                allowFileAccess
                scalesPageToFit
                originWhitelist={['*']}
                onContentProcessDidTerminate={async (syntheticEvent) => {
                  const { nativeEvent } = syntheticEvent;
                  console.warn('Content process terminated, reloading', nativeEvent);
                  webview.reload();
                }}
              />
            )}
          </View>
        )}

        {(((data && data.toString() !== '') || !withCookie) && isFocused && isInitialized) ||
        webHtml ? (
          <View style={{ height: '100%' }}>
            <WebView
              originWhitelist={['*']}
              ref={(ref: WebView) => {
                webview = ref;
              }}
              source={
                webHtml
                  ? {
                      html: webHtml,
                    }
                  : handleSpecialFileExt(webUrl)
              }
              // renderLoading={LoadingIndicatorView}
              startInLoadingState
              // onNavigationStateChange={onShouldStartLoadWithRequest}
              onMessage={onMessage}
              allowsFullscreenVideo
              allowsInlineMediaPlayback
              mixedContentMode="always"
              androidLayerType="none"
              sharedCookiesEnabled
              userAgent={userAgent}
              javaScriptEnabled
              allowFileAccess
              scalesPageToFit
              incognito={isIncognito}
              {...INJECTEDJAVASCRIPT}
              onLoadStart={onLoadStart}
              onLoadProgress={onLoadProgress}
              onLoadEnd={onLoadEnd}
              onError={onError}
              onShouldStartLoadWithRequest={onShouldStartLoadWithRequest}
              onNavigationStateChange={(navState) => {
                if (webHtml) {
                  return;
                }
                if (
                  props.fromTraining &&
                  !navState.url.includes(constants.WebviewMobileSuffix) &&
                  !navState.url.startsWith(PRU_SSO_BASE) &&
                  !navState.url.includes(constants.TrainingLoginSuffix)
                ) {
                  setWebUrl(navState.url + constants.WebviewMobileSuffix);
                }
              }}
              onContentProcessDidTerminate={async (syntheticEvent) => {
                const { nativeEvent } = syntheticEvent;
                console.warn('Content process terminated, reloading', nativeEvent);
                webview.reload();
              }}
              {...originProps}
            />
          </View>
        ) : (
          LoadingIndicatorView()
        )}
      </KeyboardAvoidingView>

      {(webUrl && webUrl.includes(ASKPRU)) || hideFooter ? (
        // || webUrl.includes(WEBMAIL)
        <View style={styles.bottom_null} />
      ) : (
        <View style={styles.bottom}>
          <TouchableOpacity
            accessibilityLabel="web_back"
            accessible={false}
            onPress={() => (webview ? webview.goBack() : null)}>
            <PruIconFont
              name="arrow"
              style={{ transform: [{ rotateY: '180deg' }] }}
              color={PruPalette.grey33}
              size={24}
            />
          </TouchableOpacity>
          <TouchableOpacity
            accessibilityLabel="web_refresh"
            accessible={false}
            onPress={() => (webview ? webview.reload() : null)}>
            <PruIconFont name="refresh" color={PruPalette.grey33} size={24} />
          </TouchableOpacity>
          <TouchableOpacity
            accessibilityLabel="web_forward"
            accessible={false}
            onPress={() => (webview ? webview.goForward() : null)}>
            <PruIconFont name="arrow" color={PruPalette.grey33} size={24} />
          </TouchableOpacity>
        </View>
      )}
    </PruScreen>
  );
};
