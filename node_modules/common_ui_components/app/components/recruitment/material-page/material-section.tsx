import { useFocusEffect } from '@react-navigation/core';
import {
  selectResourcesLoaded,
  selectResources,
  fetchResourceAsync,
  ResourceContentType,
  SortedMethodType,
  Resource,
  ResourceCategory,
  selectFetchResourcesErrorMessage,
  LoggerHelper,
  LogActionType,
  LogSourceType,
  LogRemark,
  resetResourceState,
  GlobalHelper,
  CommonApi,
  getGeneralApiProblem,
  getContentSalesReadlogAsync,
  selectContentReadlog,
  ContentSalesReadlog,
} from 'common_services_frontend';
import React, { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { Dimensions, FlatList, View } from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { throttle } from 'lodash';
import { CONTENT_TYPE } from 'common_services_frontend/src/common-logic/portal-resource';
import { ResourceStatuses } from 'common_services_frontend/src/services/contentful/delivery';
import { palette, spacing } from '../../../theme';
import { ResourceList } from '../resource-list/resource-list';
import { ErrorPage } from '../../error-page/error-page';
import { PruActivityIndicator } from '../../common/ActivityIndicator';
import { CategoryLabel, ScrollCategoryList } from '../scroll-category-list/scroll-category-list';
import { ItemSeparatorWrap } from '../../common/item-separator/item-separator';

export interface MaterialSectionProps {
  tabLabel?: string;
  onResourceSearch: Function;
  onResourceItemPressed: Function;
  contentType: ResourceContentType;
  tagWithCount?: boolean;
  searchKey?: string;
  search?: boolean;
  refresh?: boolean;
  isHeaderHide?: boolean;
  sortedMethod?: SortedMethodType;
}

let pickedCategoryIds: string[] = [];
let pickedValues: string[] = [];
let goDetail = false;
let _throttleFunc: any;

export const MaterialSection: React.FunctionComponent<MaterialSectionProps> = (props) => {
  const { t, i18n } = useTranslation();
  const dispatch = useDispatch();
  const [resources, setResources] = useState([] as Resource[]);
  const [readLogs, setReadLogs] = useState([] as ContentSalesReadlog[]);

  const [searchedResources, setSearchedResources] = useState([] as Resource[]);
  const [pickedCategoryValues, setPickedCategoryValues] = useState(['All']);
  const [dataLoaded, setDataLoaded] = useState(false);
  const [resourceCategories, setResourceCategories] = useState([] as CategoryLabel[]);
  const isDataLoaded = useSelector(selectResourcesLoaded);

  useEffect(() => {
    setDataLoaded(isDataLoaded);
  }, [isDataLoaded]);
  const errorSelector = useSelector(selectFetchResourcesErrorMessage);

  const ItemSeparator = ItemSeparatorWrap({
    width: '100%',
    height: spacing.spacing12,
    backgroundColor: palette.greyeb,
  });
  const resourceSelector = useSelector(selectResources);

  const contentReadlogSelector = useSelector(selectContentReadlog);

  useFocusEffect(
    useCallback(() => {
      setReadLogs(contentReadlogSelector);
    }, [contentReadlogSelector]),
  );

  useFocusEffect(
    useCallback(() => {
      if (
        GlobalHelper.getRecruitmentTab() !== 1 &&
        !globalThis.CONFIGURATION?.Recruitment?.disableCandidateModule &&
        props.contentType === ResourceContentType.RecruitmentMaterial
      ) {
        return;
      }

      if (props.searchKey || props.searchKey === undefined) {
        // Why do we need to judge props.searchKey === undefined, because the list page satisfies props.searchKey === undefined
        // and needs to be automatically refreshed for the first time, but the search page is not required
        dispatch(fetchResourceAsync({ langkey: i18n.language, contentType: props.contentType }));
        dispatch(getContentSalesReadlogAsync());

        if (props.searchKey) {
          if (!_throttleFunc) {
            _throttleFunc = throttle(
              (keyWords) => {
                LoggerHelper.emit(
                  {
                    source: '',
                    sourceType: LogSourceType.RESOURCE,
                    actionType: LogActionType.SEARCH,
                  },
                  {
                    key_words: keyWords,
                    action_entry: LoggerHelper.getEntry(),
                  },
                );
              },
              3000,
              { trailing: true, leading: false },
            );
          }
          _throttleFunc(props.searchKey);
        }
      }
      // avoid get extra data from unselected categories
      // return () => {
      //   dispatch(resetResourceState());
      // };
    }, [i18n.language, props.searchKey, props.refresh]),
  );

  useFocusEffect(
    useCallback(() => {
      goDetail = false;
      return () => {
        if (!goDetail) {
          pickedCategoryIds = [];
          goDetail = false;
          setResources([]);
        }
        _throttleFunc = null;
      };
    }, []),
  );
  useEffect(() => {
    if (props.search) {
      if (!props.searchKey) {
        setSearchedResources([]);
      } else {
        const searchResult = resourceSelector.filter((resource: Resource) => {
          return (
            resource.searchTargetString &&
            resource.searchTargetString
              .toLocaleLowerCase()
              .includes((props.searchKey || '').toLocaleLowerCase())
          );
        });
        setSearchedResources(sortResources(searchResult));
      }
    } else {
      setSearchedResources(
        sortResources(
          resourceSelector.filter((resource: Resource) => {
            return resource.status !== ResourceStatuses.SetOnly;
          }),
        ),
      );
    }
  }, [resourceSelector, props.searchKey, props.sortedMethod]);

  useEffect(() => {
    setResources(sortResources(searchedResources));
    pickedValues = [];
    let categories: ResourceCategory[] = [];
    for (let index = 0; index < searchedResources.length; index++) {
      const resource: Resource = searchedResources[index];
      categories = categories.concat(resource.category);
    }
    const categoryIds = [];
    const categoryMapId2Obj: { [key: string]: CategoryLabel } = {};
    for (let index = 0; index < categories.length; index++) {
      const category = categories[index];
      categoryIds.push(category.id);
      if (!categoryMapId2Obj[category.id]) {
        categoryMapId2Obj[category.id] = {
          id: category.id,
          label: category.name,
          value: category.name,
          weight: category.weight,
          counts: 1,
        };
      } else {
        const tagCounts = (categoryMapId2Obj[category.id].counts || 0) + 1;
        categoryMapId2Obj[category.id].counts = tagCounts;
      }
      if (pickedCategoryIds.includes(category.id)) {
        pickedValues.push(category.name);
      }
    }
    if (props.tagWithCount) {
      for (const key in categoryMapId2Obj) {
        if (Object.prototype.hasOwnProperty.call(categoryMapId2Obj, key)) {
          const tagProps = categoryMapId2Obj[key];
          tagProps.label = `${tagProps.label}(${tagProps.counts})`;
        }
      }
    }
    if (pickedValues.length) {
      setPickedCategoryValues(pickedValues);
    }
    const catSets = props.tagWithCount ? categoryIds : [...new Set(categoryIds)];
    setResourceCategories(
      catSets.map((id) => {
        return categoryMapId2Obj[id];
      }),
    );
    // 考虑到栏目选中的情况，每次数据刷新，但当前选中栏目是没有自动变化的，所以要进行过滤
    refreshFilterData(pickedCategoryValues);
  }, [searchedResources]);

  const refreshFilterData = (selectedCategories: string[]) => {
    const filterData = searchedResources.filter((resource: Resource) => {
      if (selectedCategories.includes('All')) {
        return true;
      }
      for (let index = 0; index < resource.category.length; index++) {
        const category = resource.category[index];
        if (selectedCategories.includes(category.name)) {
          return true;
        }
      }
      return false;
    });
    setResources(sortResources(filterData));
  };
  // 默认排序
  const weightResource = (resourceA: Resource, resourceB: Resource): number => {
    const sortColumn = (colA: ResourceCategory, colB: ResourceCategory) => {
      return colB.itemWeight - colA.itemWeight;
    };
    const filterColumn = (column: ResourceCategory) => {
      if (pickedCategoryIds.length) {
        return pickedCategoryIds.includes(column.id);
      }
      return true;
    };
    const columnsA: ResourceCategory[] = [...resourceA.category]
      .filter(filterColumn)
      .sort(sortColumn);
    const columnsB: ResourceCategory[] = [...resourceB.category]
      .filter(filterColumn)
      .sort(sortColumn);
    if (!columnsB[0]) {
      return -1;
    }
    if (!columnsA[0]) {
      return 1;
    }
    if (columnsA[0].itemWeight === columnsB[0].itemWeight) {
      // 如果最大權重相等，就按column權重排序
      if (columnsA[0].weight === columnsB[0].weight) {
        // 如果column的權重還相同，就按時間排序
        if (resourceB.updated_at === resourceA.updated_at) {
          // 如果updated_at也相同，則再按title排序
          if (resourceB.title > resourceA.title) {
            return 1;
          }
          if (resourceB.title < resourceA.title) {
            return -1;
          }
        } else {
          return resourceB.updated_at - resourceA.updated_at;
        }
      } else {
        return columnsB[0].weight - columnsA[0].weight;
      }
    } else {
      return columnsB[0].itemWeight - columnsA[0].itemWeight;
    }
  };
  // 先按未读消息排序，再默认排序
  const weightResourceByUnread = (resourceA: Resource, resourceB: Resource): number => {
    const resourceAUnreadStatus =
      readLogs?.find((log) => {
        return log.contentId === resourceA.uuid;
      }) === undefined
        ? 1
        : 0;

    const resourceBUnreadStatus =
      readLogs?.find((log) => {
        return log.contentId === resourceB.uuid;
      }) === undefined
        ? 1
        : 0;
    if (resourceAUnreadStatus === resourceBUnreadStatus) {
      return weightResource(resourceA, resourceB);
    }
    return resourceBUnreadStatus - resourceAUnreadStatus;
  };

  // 按发布时间进行排序，再进行默认排序
  const weightResourceByPublishDate = (resourceA: Resource, resourceB: Resource): number => {
    if (resourceB.lastPublishTime === resourceA.lastPublishTime) {
      return weightResource(resourceA, resourceB);
    }
    return resourceB.updated_at - resourceA.updated_at;
  };

  const sortResources = (rawResources: Resource[]) => {
    const promotionResources: Resource[] = rawResources.filter(function (res) {
      return res.module === 'Promotion';
    });
    const otherResources: Resource[] = rawResources.filter(function (res) {
      return res.module !== 'Promotion';
    });

    if (props.sortedMethod === SortedMethodType.LATEST) {
      return promotionResources
        .sort(weightResourceByPublishDate)
        .concat(otherResources.sort(weightResourceByPublishDate));
    }
    if (props.sortedMethod === SortedMethodType.UNREAD) {
      return promotionResources
        .sort(weightResourceByUnread)
        .concat(otherResources.sort(weightResourceByUnread));
    }

    return promotionResources.sort(weightResource).concat(otherResources.sort(weightResource));
  };

  return (
    <View style={{ backgroundColor: palette.greyeb, flex: 1 }}>
      <FlatList
        style={{
          width: Dimensions.get('window').width,
          backgroundColor: palette.greyeb,
        }}
        data={null}
        renderItem={null}
        refreshing={false}
        onRefresh={() => {
          dispatch(fetchResourceAsync({ langkey: i18n.language, contentType: props.contentType }));
          dispatch(getContentSalesReadlogAsync());
        }}
        ListHeaderComponent={
          <>
            {props.isHeaderHide ? null : !isDataLoaded ? (
              props.searchKey === '' ? null : (
                <PruActivityIndicator />
              )
            ) : (
              <ScrollCategoryList
                onLabelPressed={(selectedCategories: CategoryLabel[]) => {
                  LoggerHelper.emit(
                    {
                      source: selectedCategories[0].value,
                      sourceType: LogSourceType.RESOURCE_COLUMN,
                      actionType: LogActionType.SWITCH,
                      remarks: LogRemark.SWITCH_COLUMN,
                    },
                    {
                      action_entry: LoggerHelper.getEntry({ isChangeRoute: false }),
                    },
                  );
                  // 记住当前选中的column id, 当切换系统语言时，还能记住当前选中的column
                  pickedCategoryIds = selectedCategories.map((item) => item.id).filter((id) => id);
                  // tag label变更时筛选数据
                  const categoryValues = selectedCategories.map((item) => item.value);
                  setPickedCategoryValues([...new Set(categoryValues)]);
                  refreshFilterData(categoryValues);
                }}
                inputTagList={[...new Set(resourceCategories)]}
                inputSelectedTagList={pickedCategoryValues}
              />
            )}
          </>
        }
        ListFooterComponent={
          <>
            {!isDataLoaded ? null : (
              <>
                {resources.length ? (
                  <>
                    <ItemSeparator />
                    <ResourceList
                      data={resources}
                      readLog={readLogs}
                      highlightText={props.searchKey}
                      onItemPressed={(resource) => {
                        goDetail = true;
                        const pickedColumn =
                          (pickedCategoryValues &&
                            pickedCategoryValues.length &&
                            [...new Set(pickedCategoryValues)].join('|')) ||
                          'All';
                        LoggerHelper.emit(
                          {
                            source: `${resource.title}(${resource.sid})`,
                            sourceType: LogSourceType.RESOURCE_LIBRARY,
                            actionType: LogActionType.VIEW,
                            remarks:
                              resource.type === CONTENT_TYPE.Set
                                ? LogRemark.PREVIEW_RESOURCE_SET
                                : LogRemark.PREVIEW_RESOURCE,
                          },
                          {
                            resource_column: pickedColumn,
                            key_words: props.searchKey,
                            // 點擊時還沒有切換路由，入口即是當前頁面
                            action_entry: LoggerHelper.getEntry({ isChangeRoute: false }),
                          },
                        );
                        props.onResourceItemPressed({
                          ...resource,
                          resource_column: pickedColumn,
                          key_words: props.searchKey,
                          // 點擊時還沒有切換路由，入口即是當前頁面
                          action_entry: LoggerHelper.getEntry({ isChangeRoute: false }),
                        });
                      }}
                    />
                  </>
                ) : (props.search && !props.searchKey) || !dataLoaded ? null : (
                  <View
                    style={{
                      height: Dimensions.get('window').height - 88,
                    }}>
                    {errorSelector ? (
                      <ErrorPage
                        style={{
                          paddingTop: 93,
                        }}
                        icon={errorSelector}
                        textKey={errorSelector}
                      />
                    ) : (
                      <ErrorPage
                        style={{
                          paddingTop: 93,
                        }}
                        icon="no_results_matched"
                        textKey="no_results_matched"
                      />
                    )}
                  </View>
                )}
              </>
            )}
          </>
        }
      />
    </View>
  );
};
