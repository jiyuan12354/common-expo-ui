import { useFocusEffect, useNavigation } from '@react-navigation/core';
import {
  selectEventsLoaded,
  selectEvents,
  fetchEventAsync,
  EventContentType,
  Event,
  selectFetchEventsErrorMessage,
  LoggerHelper,
  LogActionType,
  LogSourceType,
  AppRoutes,
  selectEventFilterIsSet,
} from 'common_services_frontend';
import { ItemSeparatorWrap } from 'common_ui_components/app/components/common/item-separator/item-separator';
import React, { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { Dimensions, FlatList, RefreshControl, Text, View } from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { color, palette, spacing, textStyleSet } from 'common_ui_components/app/theme';
import { EventList } from 'common_ui_components/app/components/events/event-list/event-list';
import { ErrorPage } from 'common_ui_components/app/components/error-page/error-page';
import { throttle } from 'lodash';
import { Toast } from 'common_ui_components/app/components';
import { CommonTranslateKey } from 'common_ui_components/app/translation/__translation-keys';
import { pruTestID } from 'common_services_frontend';

export interface EventSectionProps {
  tabLabel?: string;
  contentType: EventContentType;
  tagWithCount?: boolean;
  searchKey?: string;
  search?: boolean;
  refresh?: boolean;
}

let pickedCategoryIds: string[] = [];
let goDetail = false;
let _throttleFunc: any;

const weightEvent = (eventA: Event, eventB: Event): number => {
  return eventB.weight - eventA.weight;
};

const sortEvents = (rawEvents: Event[]) => {
  return rawEvents.sort(weightEvent);
};

let filterClickedCounts = 0;
export const EventSection: React.FunctionComponent<EventSectionProps> = (props) => {
  const { t, i18n } = useTranslation();
  const dispatch = useDispatch();
  const navigation = useNavigation();
  const [events, setEvents] = useState([] as Event[]);
  const [searchedEvents, setSearchedEvents] = useState([] as Event[]);
  const [dataLoaded, setDataLoaded] = useState(false);
  const isDataLoaded = useSelector(selectEventsLoaded);
  const filterOptions = useSelector((state: any) => state.event.filterOption);
  const isSetFilter = useSelector(selectEventFilterIsSet);
  useEffect(() => {
    const timmer = setTimeout(() => {
      setDataLoaded(isDataLoaded);
    }, 1000);
    return () => {
      clearTimeout(timmer);
    };
  }, [isDataLoaded]);
  const errorSelector = useSelector(selectFetchEventsErrorMessage);

  const ItemSeparator = ItemSeparatorWrap({
    width: '100%',
    height: spacing.spacing12,
    backgroundColor: color.transparent,
  });
  const eventSelector = useSelector(selectEvents);

  useFocusEffect(
    useCallback(() => {
      if (props.searchKey || props.searchKey === undefined) {
        // Why do we need to judge props.searchKey === undefined, because the list page satisfies props.searchKey === undefined
        // and needs to be automatically refreshed for the first time, but the search page is not required
        dispatch(fetchEventAsync());
        if (props.searchKey) {
          if (!_throttleFunc) {
            _throttleFunc = throttle(
              (keyWords) => {
                LoggerHelper.emit(
                  {
                    source: '',
                    sourceType: LogSourceType.RESOURCE,
                    actionType: LogActionType.SEARCH,
                  },
                  {
                    key_words: keyWords,
                    action_entry: LoggerHelper.getEntry(),
                  },
                );
              },
              3000,
              { trailing: true, leading: false },
            );
          }
          _throttleFunc(props.searchKey);
        }
      }
      return () => {
        // dispatch(resetEventState());
      };
    }, [i18n.language, props.searchKey, props.refresh]),
  );
  useFocusEffect(
    useCallback(() => {
      filterClickedCounts = 0;
      return () => {
        if (!goDetail) {
          pickedCategoryIds = [];
        }
        goDetail = false;
        setEvents([]);
        _throttleFunc = null;
      };
    }, []),
  );
  useEffect(() => {
    if (props.search) {
      if (!props.searchKey) {
        setSearchedEvents([]);
      } else {
        const searchResult = eventSelector.filter((event: Event) => {
          return (
            event.searchTargetString &&
            event.searchTargetString
              .toLocaleLowerCase()
              .includes((props.searchKey || '').toLocaleLowerCase())
          );
        });
        setSearchedEvents(sortEvents(searchResult));
      }
    } else {
      let events: Event[] = [...eventSelector];
      if (isSetFilter) {
        const filters: Function[] = [];
        const pickedCategories = filterOptions.pickedCategoryValues;
        if (pickedCategories && pickedCategories.length) {
          const filterFunc = (item: Event) => {
            return pickedCategories.includes(item.categories[0].value);
          };
          filters.push(filterFunc);
        }
        const pickedStatus = filterOptions.pickedStatusValues;
        if (pickedStatus && pickedStatus.length) {
          const filterFunc = (item: Event) => {
            const nowTs = new Date().getTime();
            if (
              pickedStatus.includes('ongoing') &&
              item.startTime < nowTs &&
              item.endTime > nowTs
            ) {
              return true;
            }
            if (pickedStatus.includes('upcoming') && item.startTime > nowTs) {
              return true;
            }
            if (pickedStatus.includes('expired') && item.endTime < nowTs) {
              return true;
            }
            return false;
          };
          filters.push(filterFunc);
        }
        const pickedStartTs = filterOptions.startDateTs;
        const pickedEndTs = filterOptions.endDateTs;
        if (pickedStartTs || pickedEndTs) {
          const filterFunc = (item: Event) => {
            return (
              (item.endTime > pickedStartTs || !pickedStartTs) &&
              (item.startTime < pickedEndTs || !pickedEndTs)
            );
          };
          filters.push(filterFunc);
        }
        events = events.filter((item: Event) => {
          // eslint-disable-next-line no-plusplus
          for (let index = 0; index < filters.length; index++) {
            if (!filters[index](item)) {
              return false;
            }
          }
          return true;
        });
      }
      setSearchedEvents(sortEvents(events));
    }
  }, [eventSelector, props.searchKey, filterOptions]);

  useEffect(() => {
    setEvents(sortEvents(searchedEvents));
  }, [searchedEvents]);
  useEffect(() => {
    if (filterOptions.filterClickedCounts !== filterClickedCounts && isSetFilter) {
      filterClickedCounts = filterOptions.filterClickedCounts;
      if (dataLoaded) {
        Toast({
          message: events?.length
            ? t(CommonTranslateKey.events_matched, {
                count: events?.length || 0,
              })
            : t(CommonTranslateKey.no_event_matched).toLocaleLowerCase(),
        });
      }
    }
  }, [events]);

  return (
    <View style={{ backgroundColor: palette.white, flex: 1 }}>
      {props.searchKey && events?.length ? (
        <Text
          {...pruTestID('ResultCount')}
          style={{
            ...textStyleSet.content_14_med,
            lineHeight: 22,
            color: palette.grey85,
            marginLeft: 20,
            marginTop: 5,
            marginBottom: -5,
            paddingVertical: 4,
          }}>
          {t(CommonTranslateKey.events_matched, {
            count: events?.length || 0,
          })}
        </Text>
      ) : null}
      <FlatList
        style={{
          width: Dimensions.get('window').width,
          backgroundColor: palette.white,
        }}
        data={null}
        renderItem={null}
        refreshControl={
          <RefreshControl
            colors={[palette.red, palette.cobalt]}
            tintColor={palette.red}
            refreshing={!isDataLoaded}
            onRefresh={() => {
              setDataLoaded(false);
              dispatch(fetchEventAsync());
            }}
          />
        }
        refreshing={false}
        onRefresh={() => {}}
        ListFooterComponent={
          <>
            {!isDataLoaded ? null : (
              <>
                {events.length ? (
                  <>
                    <ItemSeparator />
                    <EventList
                      data={events}
                      highlightText={props.searchKey}
                      onItemPressed={(item) => {
                        navigation.navigate(AppRoutes.HOME_EventDetailsScreen, {
                          eventId: item.id,
                        });
                      }}
                    />
                  </>
                ) : (props.search && !props.searchKey) || !dataLoaded ? null : (
                  <View
                    style={{
                      height: Dimensions.get('window').height - 88,
                    }}>
                    {errorSelector ? (
                      <ErrorPage
                        style={{
                          marginTop: 93,
                        }}
                        icon={errorSelector}
                        textKey={errorSelector}
                      />
                    ) : (
                      <ErrorPage
                        style={{
                          marginTop: 93,
                        }}
                        icon={isSetFilter || props.searchKey ? 'no_results_matched' : 'no_content'}
                        textKey={isSetFilter || props.searchKey ? 'no_event_matched' : 'no_event'}
                      />
                    )}
                  </View>
                )}
              </>
            )}
          </>
        }
      />
    </View>
  );
};
