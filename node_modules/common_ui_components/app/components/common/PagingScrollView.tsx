import React, { FC, useState, useReducer } from 'react';
import {
  ScrollView,
  View,
  ActivityIndicator,
  NativeSyntheticEvent,
  NativeScrollEvent,
  ScrollViewProps,
  StyleProp,
  ViewStyle,
} from 'react-native';

type PagingScrollViewProps<ListItem> = {
  height?: number | string;
  nextPageThreshold?: number;
  perPage: number;
  namespace: string;
  initialData: ListItem[];
  renderIfEmpty: JSX.Element;
  itemTemplate: FC<ListItem>;
  containerStyle?: StyleProp<ViewStyle>;
  onScrollEnd: (offset: number) => Promise<ListItem[]>; // This Parameter must pass in a function which returns list of data
} & ScrollViewProps;

type PaginationState<ListItem> = {
  offset: number;
  itemList: ListItem[];
};

type AppendDataAction<ListItem> = {
  type: 'APPEND_DATA';
  payload: {
    itemList: ListItem[];
  };
};

type PaginationAction<ListItem> = AppendDataAction<ListItem>;

const PagingScrollView = <ListItem extends object>({
  height,
  perPage,
  nextPageThreshold,
  namespace,
  itemTemplate,
  renderIfEmpty,
  initialData,
  containerStyle,
  onScrollEnd,
  ...rest
}: PagingScrollViewProps<ListItem>) => {
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const [listState, listDispatch] = useReducer(
    (state: PaginationState<ListItem>, action: PaginationAction<ListItem>) => {
      switch (action.type) {
        case 'APPEND_DATA': {
          let newState = { ...state };
          if (action.payload.itemList.length < 1) {
            return newState;
          }
          newState.itemList = [...state.itemList, ...action.payload.itemList];
          newState.offset = state.offset + perPage;
          return newState;
        }
        default:
          return state;
      }
    },
    {
      offset: initialData.length,
      itemList: initialData,
    },
  );

  const isScrollEnd = (event: NativeSyntheticEvent<NativeScrollEvent>) => {
    const threshold = nextPageThreshold ? nextPageThreshold : 0;
    const { layoutMeasurement, contentOffset } = event.nativeEvent;
    return layoutMeasurement.height + contentOffset.y > layoutMeasurement.height + threshold;
  };

  const onNextPage = () => {
    setIsLoading(true);
    onScrollEnd(listState.offset)
      .then((result) => {
        listDispatch({
          type: 'APPEND_DATA',
          payload: {
            itemList: result,
          },
        });
      })
      .catch((err) => {
        console.log('Error: ' + err);
      })
      .finally(() => {
        setIsLoading(false);
      });
  };

  return (
    <ScrollView
      style={[containerStyle, { height: height || 0 }]}
      scrollEventThrottle={400}
      onScroll={(event) => {
        if (isScrollEnd(event) && !isLoading) {
          onNextPage();
        }
      }}
      {...rest}>
      {listState.itemList.length > 0 ? (
        listState.itemList.map((item, index) =>
          React.createElement(itemTemplate, {
            key: `${namespace}-item-${index}`,
            itemIndex: index,
            ...item,
          }),
        )
      ) : (
          <>{renderIfEmpty}</>
        )}
      {isLoading && (
        <View style={{ padding: 5 }}>
          <ActivityIndicator />
        </View>
      )}
    </ScrollView>
  );
};

export default PagingScrollView;
