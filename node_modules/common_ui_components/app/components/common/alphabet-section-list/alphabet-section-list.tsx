import * as React from 'react';
import {
  SectionList,
  SectionListProps,
  TextStyle,
  View,
  Text,
  ViewStyle,
  Dimensions,
  SectionListData,
  PanResponder,
} from 'react-native';
import { color, palette, textStyleSet } from '../../../theme';

const CONTAINER: ViewStyle = {
  backgroundColor: color.greyeb,
  flex: 1,
};
const { width, height } = Dimensions.get('window');
const sectionWidth = 20;
const sectionTopBottomHeight = 60;

export interface AlphabetSectionListProps<ItemT = any> extends SectionListProps<ItemT> {
  style?: ViewStyle;
  sectionHeight: number;
}
/**
 * Describe your component here
 */
export class AlphabetSectionList extends React.Component<AlphabetSectionListProps> {
  sectionListRef = null;
  panResponder = {};
  constructor(props: AlphabetSectionListProps<any>) {
    super(props);
    this.sectionListRef = React.createRef();
    this.state = {
      sectionListDatas: props.sections,
      dragging: false,
      // initialTop: 50,
      initialLeft: 50,
      offsetTop: 0,
      offsetLeft: 0,
    };
  }

  UNSAFE_componentWillMount() {
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: this.handleStartShouldSetPanResponder,
      onPanResponderGrant: this.handlePanResponderGrant,
      onPanResponderMove: this.handlePanResponderMove,
      onPanResponderRelease: this.handlePanResponderEnd,
      onPanResponderTerminate: this.handlePanResponderEnd,
    });
  }
  scrollToList(index) {
    this.sectionListRef.current.scrollToLocation({
      animated: false,
      itemIndex: 0,
      sectionIndex: parseInt(index),
      // viewOffset: this.props.sectionHeight,
    });
  }
  /*右侧索引*/
  renderSideSectionView(sectionData) {
    const sectionItem = sectionData.map((item, index) => {
      return (
        <Text
          onPress={() => this.scrollToList(index)}
          key={index}
          style={{
            ...textStyleSet.info_12_med,
            color: palette.grey66,
            textAlign: 'center',
            alignItems: 'center',
            // height: sectionItemHeight,
            lineHeight: 20,
          }}>
          {item.title}
        </Text>
      );
    });

    return (
      <View
        style={{
          position: 'absolute',
          width: sectionWidth,
          height: height - sectionTopBottomHeight * 2,
          right: 5,
          top: 0,
          marginTop: sectionTopBottomHeight,
          marginBottom: sectionTopBottomHeight,
        }}
        ref="sectionItemView"
        // onStartShouldSetResponder={()=>true} // 在用户开始触摸的时候（手指刚刚接触屏幕的瞬间），是否愿意成为响应者？
        // onMoveShouldSetResponder={()=>true} // :如果View不是响应者，那么在每一个触摸点开始移动（没有停下也没有离开屏幕）时再询问一次：是否愿意响应触摸交互呢？
        // onResponderGrant={this.responderGrant.bind(this)} // View现在要开始响应触摸事件了。这也是需要做高亮的时候，使用户知道他到底点到了哪里
        // onResponderMove={this.responderMove.bind(this)} // 用户正在屏幕上移动手指时（没有停下也没有离开屏幕）
        // onResponderRelease={this.responderRelease.bind(this)} // 触摸操作结束时触发，比如"touchUp"（手指抬起离开屏幕）
      >
        {sectionItem}
      </View>
    );
  }

  render() {
    const { style, getItemLayout, ...rest } = this.props;
    let _getItemLayout: any = getItemLayout;
    return (
      <View style={[CONTAINER, style]}>
        <SectionList
          {...this.panResponder.panHandlers}
          ref={this.sectionListRef}
          showsVerticalScrollIndicator={false}
          showsHorizontalScrollIndicator={false}
          getItemLayout={(data: Array<object>, index: number) => _getItemLayout(data, index)}
          {...rest}
          ListFooterComponent={
            <View
              style={{
                height: 100,
                width: '100%',
                backgroundColor: palette.greyeb,
              }}></View>
          }
        />
        {this.renderSideSectionView([...this.props.sections])}
      </View>
    );
  }

  // Should we become active when the user presses down on the square?
  handleStartShouldSetPanResponder = () => {
    return true;
  };

  // We were granted responder status! Let's update the UI
  handlePanResponderGrant = () => {
    this.setState({ dragging: true });
  };

  // Every time the touch/mouse moves
  handlePanResponderMove = (e, gestureState) => {
    // Keep track of how far we've moved in total (dx and dy)
    this.setState({
      offsetTop: gestureState.dy,
      offsetLeft: gestureState.dx,
    });
  };

  // When the touch/mouse is lifted
  handlePanResponderEnd = (e, gestureState) => {
    const { initialTop, initialLeft } = this.state;

    // The drag is finished. Set the initialTop and initialLeft so that
    // the new position sticks. Reset offsetTop and offsetLeft for the next drag.
    this.setState({
      dragging: false,
      initialTop: initialTop + gestureState.dy,
      initialLeft: initialLeft + gestureState.dx,
      offsetTop: 0,
      offsetLeft: 0,
    });
  };
}
